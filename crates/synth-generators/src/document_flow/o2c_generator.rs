//! Order-to-Cash (O2C) flow generator.
//!
//! Generates complete O2C document chains:
//! SalesOrder → Delivery → CustomerInvoice → CustomerReceipt (Payment)

use chrono::NaiveDate;
use rand::prelude::*;
use rand_chacha::ChaCha8Rng;
use rust_decimal::Decimal;
use synth_core::models::{
    documents::{
        CustomerInvoice, CustomerInvoiceItem, Delivery, DeliveryItem, DocumentReference,
        DocumentStatus, DocumentType, Payment, PaymentMethod, ReferenceType, SalesOrder,
        SalesOrderItem, SalesOrderType,
    },
    CreditRating, Customer, CustomerPool, Material, MaterialPool, PaymentTerms,
};

/// Configuration for O2C flow generation.
#[derive(Debug, Clone)]
pub struct O2CGeneratorConfig {
    /// Credit check failure rate
    pub credit_check_failure_rate: f64,
    /// Rate of partial shipments
    pub partial_shipment_rate: f64,
    /// Average days between SO and Delivery
    pub avg_days_so_to_delivery: u32,
    /// Average days between Delivery and Invoice
    pub avg_days_delivery_to_invoice: u32,
    /// Average days between Invoice and Payment (customer payment)
    pub avg_days_invoice_to_payment: u32,
    /// Late payment rate
    pub late_payment_rate: f64,
    /// Bad debt rate (no payment)
    pub bad_debt_rate: f64,
    /// Rate of sales returns
    pub returns_rate: f64,
    /// Cash discount take rate
    pub cash_discount_take_rate: f64,
    /// Payment method distribution for AR receipts
    pub payment_method_distribution: Vec<(PaymentMethod, f64)>,
}

impl Default for O2CGeneratorConfig {
    fn default() -> Self {
        Self {
            credit_check_failure_rate: 0.02,
            partial_shipment_rate: 0.08,
            avg_days_so_to_delivery: 5,
            avg_days_delivery_to_invoice: 1,
            avg_days_invoice_to_payment: 30,
            late_payment_rate: 0.15,
            bad_debt_rate: 0.02,
            returns_rate: 0.03,
            cash_discount_take_rate: 0.25,
            payment_method_distribution: vec![
                (PaymentMethod::BankTransfer, 0.50),
                (PaymentMethod::Check, 0.30),
                (PaymentMethod::Wire, 0.15),
                (PaymentMethod::CreditCard, 0.05),
            ],
        }
    }
}

/// A complete O2C document chain.
#[derive(Debug, Clone)]
pub struct O2CDocumentChain {
    /// Sales Order
    pub sales_order: SalesOrder,
    /// Deliveries (may be multiple for partial shipments)
    pub deliveries: Vec<Delivery>,
    /// Customer Invoice
    pub customer_invoice: Option<CustomerInvoice>,
    /// Customer Receipt (Payment)
    pub customer_receipt: Option<Payment>,
    /// Chain completion status
    pub is_complete: bool,
    /// Credit check passed
    pub credit_check_passed: bool,
    /// Is this a return/credit memo chain
    pub is_return: bool,
}

/// Generator for O2C document flows.
pub struct O2CGenerator {
    rng: ChaCha8Rng,
    seed: u64,
    config: O2CGeneratorConfig,
    so_counter: usize,
    dlv_counter: usize,
    ci_counter: usize,
    rec_counter: usize,
}

impl O2CGenerator {
    /// Create a new O2C generator.
    pub fn new(seed: u64) -> Self {
        Self::with_config(seed, O2CGeneratorConfig::default())
    }

    /// Create a new O2C generator with custom configuration.
    pub fn with_config(seed: u64, config: O2CGeneratorConfig) -> Self {
        Self {
            rng: ChaCha8Rng::seed_from_u64(seed),
            seed,
            config,
            so_counter: 0,
            dlv_counter: 0,
            ci_counter: 0,
            rec_counter: 0,
        }
    }

    /// Generate a complete O2C chain.
    pub fn generate_chain(
        &mut self,
        company_code: &str,
        customer: &Customer,
        materials: &[&Material],
        so_date: NaiveDate,
        fiscal_year: u16,
        fiscal_period: u8,
        created_by: &str,
    ) -> O2CDocumentChain {
        // Generate SO
        let mut so = self.generate_sales_order(
            company_code,
            customer,
            materials,
            so_date,
            fiscal_year,
            fiscal_period,
            created_by,
        );

        // Perform credit check
        let credit_check_passed = self.perform_credit_check(customer, so.total_gross_amount);
        so.check_credit(credit_check_passed, if !credit_check_passed {
            Some("Credit limit exceeded".to_string())
        } else {
            None
        });

        // If credit check fails, the chain may be blocked
        if !credit_check_passed {
            return O2CDocumentChain {
                sales_order: so,
                deliveries: Vec::new(),
                customer_invoice: None,
                customer_receipt: None,
                is_complete: false,
                credit_check_passed: false,
                is_return: false,
            };
        }

        // Release for delivery
        so.release_for_delivery();

        // Calculate delivery date
        let delivery_date = self.calculate_delivery_date(so_date);
        let delivery_fiscal_period = self.get_fiscal_period(delivery_date);

        // Generate delivery(s)
        let deliveries = self.generate_deliveries(
            &so,
            company_code,
            customer,
            delivery_date,
            fiscal_year,
            delivery_fiscal_period,
            created_by,
        );

        // Calculate invoice date
        let invoice_date = self.calculate_invoice_date(delivery_date);
        let invoice_fiscal_period = self.get_fiscal_period(invoice_date);

        // Release for billing
        so.release_for_billing();

        // Generate customer invoice
        let customer_invoice = if !deliveries.is_empty() {
            Some(self.generate_customer_invoice(
                &so,
                &deliveries,
                company_code,
                customer,
                invoice_date,
                fiscal_year,
                invoice_fiscal_period,
                created_by,
            ))
        } else {
            None
        };

        // Determine if customer pays
        let will_pay = self.rng.gen::<f64>() >= self.config.bad_debt_rate;

        // Calculate payment date
        let customer_receipt = if will_pay {
            customer_invoice.as_ref().map(|invoice| {
                let payment_date = self.calculate_payment_date(
                    invoice_date,
                    &customer.payment_terms,
                    customer,
                );
                let payment_fiscal_period = self.get_fiscal_period(payment_date);

                self.generate_customer_receipt(
                    invoice,
                    company_code,
                    customer,
                    payment_date,
                    fiscal_year,
                    payment_fiscal_period,
                    created_by,
                )
            })
        } else {
            None
        };

        let is_complete = customer_receipt.is_some();

        O2CDocumentChain {
            sales_order: so,
            deliveries,
            customer_invoice,
            customer_receipt,
            is_complete,
            credit_check_passed: true,
            is_return: false,
        }
    }

    /// Generate a sales order.
    pub fn generate_sales_order(
        &mut self,
        company_code: &str,
        customer: &Customer,
        materials: &[&Material],
        so_date: NaiveDate,
        fiscal_year: u16,
        fiscal_period: u8,
        created_by: &str,
    ) -> SalesOrder {
        self.so_counter += 1;

        let so_id = format!("SO-{}-{:010}", company_code, self.so_counter);

        let requested_delivery = so_date
            + chrono::Duration::days(self.config.avg_days_so_to_delivery as i64);

        let mut so = SalesOrder::new(
            so_id,
            company_code,
            &customer.customer_id,
            fiscal_year,
            fiscal_period,
            so_date,
            created_by,
        )
        .with_requested_delivery_date(requested_delivery);

        // Add line items
        for (idx, material) in materials.iter().enumerate() {
            let quantity = Decimal::from(self.rng.gen_range(1..50));
            let unit_price = material.list_price;

            let mut item = SalesOrderItem::new(
                (idx + 1) as u16 * 10,
                &material.description,
                quantity,
                unit_price,
            )
            .with_material(&material.material_id);

            // Add schedule line
            item.add_schedule_line(requested_delivery, quantity);

            so.add_item(item);
        }

        so
    }

    /// Generate deliveries for a sales order.
    fn generate_deliveries(
        &mut self,
        so: &SalesOrder,
        company_code: &str,
        customer: &Customer,
        delivery_date: NaiveDate,
        fiscal_year: u16,
        fiscal_period: u8,
        created_by: &str,
    ) -> Vec<Delivery> {
        let mut deliveries = Vec::new();

        // Determine if partial shipment
        let is_partial = self.rng.gen::<f64>() < self.config.partial_shipment_rate;

        if is_partial {
            // First shipment (60-80%)
            let first_pct = 0.6 + self.rng.gen::<f64>() * 0.2;
            let dlv1 = self.create_delivery(
                so,
                company_code,
                customer,
                delivery_date,
                fiscal_year,
                fiscal_period,
                created_by,
                first_pct,
            );
            deliveries.push(dlv1);

            // Second shipment
            let second_date = delivery_date
                + chrono::Duration::days(self.rng.gen_range(3..7) as i64);
            let second_period = self.get_fiscal_period(second_date);
            let dlv2 = self.create_delivery(
                so,
                company_code,
                customer,
                second_date,
                fiscal_year,
                second_period,
                created_by,
                1.0 - first_pct,
            );
            deliveries.push(dlv2);
        } else {
            // Full shipment
            let dlv = self.create_delivery(
                so,
                company_code,
                customer,
                delivery_date,
                fiscal_year,
                fiscal_period,
                created_by,
                1.0,
            );
            deliveries.push(dlv);
        }

        deliveries
    }

    /// Create a single delivery.
    fn create_delivery(
        &mut self,
        so: &SalesOrder,
        company_code: &str,
        customer: &Customer,
        delivery_date: NaiveDate,
        fiscal_year: u16,
        fiscal_period: u8,
        created_by: &str,
        quantity_pct: f64,
    ) -> Delivery {
        self.dlv_counter += 1;

        let dlv_id = format!("DLV-{}-{:010}", company_code, self.dlv_counter);

        let mut delivery = Delivery::from_sales_order(
            dlv_id,
            company_code,
            &so.header.document_id,
            &customer.customer_id,
            format!("SP{}", company_code),
            fiscal_year,
            fiscal_period,
            delivery_date,
            created_by,
        );

        // Add items based on SO items
        for so_item in &so.items {
            let ship_qty = (so_item.base.quantity
                * Decimal::from_f64_retain(quantity_pct).unwrap_or(Decimal::ONE))
                .round_dp(0);

            if ship_qty > Decimal::ZERO {
                // Calculate COGS (assume 60-70% of sales price)
                let cogs_pct = 0.60 + self.rng.gen::<f64>() * 0.10;
                let cogs = (so_item.base.unit_price * ship_qty
                    * Decimal::from_f64_retain(cogs_pct).unwrap_or(Decimal::from_f64_retain(0.65).unwrap()))
                    .round_dp(2);

                let mut item = DeliveryItem::from_sales_order(
                    so_item.base.line_number,
                    &so_item.base.description,
                    ship_qty,
                    so_item.base.unit_price,
                    &so.header.document_id,
                    so_item.base.line_number,
                )
                .with_cogs(cogs);

                if let Some(material_id) = &so_item.base.material_id {
                    item = item.with_material(material_id);
                }

                // Mark as picked
                item.record_pick(ship_qty);

                delivery.add_item(item);
            }
        }

        // Process delivery workflow
        delivery.release_for_picking(created_by);
        delivery.confirm_pick();
        delivery.confirm_pack(self.rng.gen_range(1..10));
        delivery.post_goods_issue(created_by, delivery_date);

        delivery
    }

    /// Generate customer invoice.
    fn generate_customer_invoice(
        &mut self,
        so: &SalesOrder,
        deliveries: &[Delivery],
        company_code: &str,
        customer: &Customer,
        invoice_date: NaiveDate,
        fiscal_year: u16,
        fiscal_period: u8,
        created_by: &str,
    ) -> CustomerInvoice {
        self.ci_counter += 1;

        let invoice_id = format!("CI-{}-{:010}", company_code, self.ci_counter);

        // Calculate due date based on payment terms
        let due_date = self.calculate_due_date(invoice_date, &customer.payment_terms);

        let mut invoice = CustomerInvoice::from_delivery(
            invoice_id,
            company_code,
            &deliveries[0].header.document_id,
            &customer.customer_id,
            fiscal_year,
            fiscal_period,
            invoice_date,
            due_date,
            created_by,
        )
        .with_payment_terms(
            customer.payment_terms.code(),
            customer.payment_terms.discount_days(),
            customer.payment_terms.discount_percent(),
        );

        // Calculate total delivered quantity per item
        let mut delivered_quantities: std::collections::HashMap<u16, (Decimal, Decimal)> =
            std::collections::HashMap::new();

        for dlv in deliveries {
            for dlv_item in &dlv.items {
                let entry = delivered_quantities
                    .entry(dlv_item.base.line_number)
                    .or_insert((Decimal::ZERO, Decimal::ZERO));
                entry.0 += dlv_item.base.quantity;
                entry.1 += dlv_item.cogs_amount;
            }
        }

        // Add invoice items based on delivered quantities
        for so_item in &so.items {
            if let Some(&(qty, cogs)) = delivered_quantities.get(&so_item.base.line_number) {
                let item = CustomerInvoiceItem::from_delivery(
                    so_item.base.line_number,
                    &so_item.base.description,
                    qty,
                    so_item.base.unit_price,
                    &deliveries[0].header.document_id,
                    so_item.base.line_number,
                )
                .with_cogs(cogs)
                .with_sales_order(&so.header.document_id, so_item.base.line_number);

                invoice.add_item(item);
            }
        }

        // Link to SO
        invoice.header.add_reference(DocumentReference::new(
            DocumentType::SalesOrder,
            &so.header.document_id,
            DocumentType::CustomerInvoice,
            &invoice.header.document_id,
            ReferenceType::FollowOn,
            company_code,
            invoice_date,
        ));

        // Link to all deliveries
        for dlv in deliveries {
            invoice.header.add_reference(DocumentReference::new(
                DocumentType::Delivery,
                &dlv.header.document_id,
                DocumentType::CustomerInvoice,
                &invoice.header.document_id,
                ReferenceType::FollowOn,
                company_code,
                invoice_date,
            ));
        }

        // Post the invoice
        invoice.post(created_by, invoice_date);

        invoice
    }

    /// Generate customer receipt (AR payment).
    fn generate_customer_receipt(
        &mut self,
        invoice: &CustomerInvoice,
        company_code: &str,
        customer: &Customer,
        payment_date: NaiveDate,
        fiscal_year: u16,
        fiscal_period: u8,
        created_by: &str,
    ) -> Payment {
        self.rec_counter += 1;

        let receipt_id = format!("REC-{}-{:010}", company_code, self.rec_counter);

        // Determine if cash discount taken
        let take_discount = invoice.discount_date_1.map_or(false, |disc_date| {
            payment_date <= disc_date && self.rng.gen::<f64>() < self.config.cash_discount_take_rate
        });

        let discount_amount = if take_discount {
            invoice.cash_discount_available(payment_date)
        } else {
            Decimal::ZERO
        };

        let payment_amount = invoice.amount_open - discount_amount;

        let mut receipt = Payment::new_ar_receipt(
            receipt_id,
            company_code,
            &customer.customer_id,
            payment_amount,
            fiscal_year,
            fiscal_period,
            payment_date,
            created_by,
        )
        .with_payment_method(self.select_payment_method())
        .with_value_date(payment_date);

        // Allocate to invoice
        receipt.allocate_to_invoice(
            &invoice.header.document_id,
            DocumentType::CustomerInvoice,
            payment_amount,
            discount_amount,
        );

        // Post the receipt
        receipt.post(created_by, payment_date);

        receipt
    }

    /// Generate multiple O2C chains.
    pub fn generate_chains(
        &mut self,
        count: usize,
        company_code: &str,
        customers: &CustomerPool,
        materials: &MaterialPool,
        date_range: (NaiveDate, NaiveDate),
        fiscal_year: u16,
        created_by: &str,
    ) -> Vec<O2CDocumentChain> {
        let mut chains = Vec::new();

        let (start_date, end_date) = date_range;
        let days_range = (end_date - start_date).num_days() as u64;

        for _ in 0..count {
            // Select random customer
            let customer_idx = self.rng.gen_range(0..customers.customers.len());
            let customer = &customers.customers[customer_idx];

            // Select random materials (1-5 items per SO)
            let num_items = self.rng.gen_range(1..=5).min(materials.materials.len());
            let selected_materials: Vec<&Material> = materials.materials
                .iter()
                .choose_multiple(&mut self.rng, num_items)
                .into_iter()
                .collect();

            // Select random SO date
            let so_date = start_date
                + chrono::Duration::days(self.rng.gen_range(0..=days_range) as i64);
            let fiscal_period = self.get_fiscal_period(so_date);

            let chain = self.generate_chain(
                company_code,
                customer,
                &selected_materials,
                so_date,
                fiscal_year,
                fiscal_period,
                created_by,
            );

            chains.push(chain);
        }

        chains
    }

    /// Perform credit check for customer.
    fn perform_credit_check(&mut self, customer: &Customer, order_amount: Decimal) -> bool {
        // Check credit limit
        if !customer.can_place_order(order_amount) {
            return false;
        }

        // Additional random failure based on config
        let fail_roll = self.rng.gen::<f64>();
        if fail_roll < self.config.credit_check_failure_rate {
            return false;
        }

        // Higher risk customers have higher failure rate
        let additional_fail_rate = match customer.credit_rating {
            CreditRating::CCC | CreditRating::D => 0.20,
            CreditRating::B | CreditRating::BB => 0.05,
            _ => 0.0,
        };

        self.rng.gen::<f64>() >= additional_fail_rate
    }

    /// Calculate delivery date from SO date.
    fn calculate_delivery_date(&mut self, so_date: NaiveDate) -> NaiveDate {
        let variance = self.rng.gen_range(0..3) as i64;
        so_date + chrono::Duration::days(self.config.avg_days_so_to_delivery as i64 + variance)
    }

    /// Calculate invoice date from delivery date.
    fn calculate_invoice_date(&mut self, delivery_date: NaiveDate) -> NaiveDate {
        let variance = self.rng.gen_range(0..2) as i64;
        delivery_date + chrono::Duration::days(self.config.avg_days_delivery_to_invoice as i64 + variance)
    }

    /// Calculate payment date based on customer behavior.
    fn calculate_payment_date(
        &mut self,
        invoice_date: NaiveDate,
        payment_terms: &PaymentTerms,
        customer: &Customer,
    ) -> NaiveDate {
        let base_days = payment_terms.net_days() as i64;

        // Adjust based on customer payment behavior
        let behavior_adjustment = match customer.payment_behavior {
            synth_core::models::CustomerPaymentBehavior::EarlyPayer => {
                -self.rng.gen_range(5..15) as i64
            }
            synth_core::models::CustomerPaymentBehavior::OnTime => {
                self.rng.gen_range(-2..3) as i64
            }
            synth_core::models::CustomerPaymentBehavior::SlightlyLate => {
                self.rng.gen_range(5..15) as i64
            }
            synth_core::models::CustomerPaymentBehavior::OftenLate => {
                self.rng.gen_range(15..45) as i64
            }
            synth_core::models::CustomerPaymentBehavior::HighRisk => {
                self.rng.gen_range(30..90) as i64
            }
        };

        // Additional random late payment
        let late_adjustment = if self.rng.gen::<f64>() < self.config.late_payment_rate {
            self.rng.gen_range(10..30) as i64
        } else {
            0
        };

        invoice_date + chrono::Duration::days(base_days + behavior_adjustment + late_adjustment)
    }

    /// Calculate due date based on payment terms.
    fn calculate_due_date(&self, invoice_date: NaiveDate, payment_terms: &PaymentTerms) -> NaiveDate {
        invoice_date + chrono::Duration::days(payment_terms.net_days() as i64)
    }

    /// Select payment method based on distribution.
    fn select_payment_method(&mut self) -> PaymentMethod {
        let roll: f64 = self.rng.gen();
        let mut cumulative = 0.0;

        for (method, prob) in &self.config.payment_method_distribution {
            cumulative += prob;
            if roll < cumulative {
                return *method;
            }
        }

        PaymentMethod::BankTransfer
    }

    /// Get fiscal period from date.
    fn get_fiscal_period(&self, date: NaiveDate) -> u8 {
        date.month() as u8
    }

    /// Reset the generator.
    pub fn reset(&mut self) {
        self.rng = ChaCha8Rng::seed_from_u64(self.seed);
        self.so_counter = 0;
        self.dlv_counter = 0;
        self.ci_counter = 0;
        self.rec_counter = 0;
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use synth_core::models::{CustomerPaymentBehavior, MaterialType};

    fn create_test_customer() -> Customer {
        let mut customer = Customer::new("C-000001", "Test Customer Inc.", "1000");
        customer.credit_rating = CreditRating::A;
        customer.credit_limit = Decimal::from(1_000_000);
        customer.payment_behavior = CustomerPaymentBehavior::OnTime;
        customer
    }

    fn create_test_materials() -> Vec<Material> {
        let mut mat1 = Material::new("MAT-001", "Test Product 1", MaterialType::FinishedGood);
        mat1.list_price = Decimal::from(100);
        mat1.standard_cost = Decimal::from(60);

        let mut mat2 = Material::new("MAT-002", "Test Product 2", MaterialType::FinishedGood);
        mat2.list_price = Decimal::from(200);
        mat2.standard_cost = Decimal::from(120);

        vec![mat1, mat2]
    }

    #[test]
    fn test_o2c_chain_generation() {
        let mut gen = O2CGenerator::new(42);
        let customer = create_test_customer();
        let materials = create_test_materials();
        let material_refs: Vec<&Material> = materials.iter().collect();

        let chain = gen.generate_chain(
            "1000",
            &customer,
            &material_refs,
            NaiveDate::from_ymd_opt(2024, 1, 15).unwrap(),
            2024,
            1,
            "JSMITH",
        );

        assert!(!chain.sales_order.items.is_empty());
        assert!(chain.credit_check_passed);
        assert!(!chain.deliveries.is_empty());
        assert!(chain.customer_invoice.is_some());
    }

    #[test]
    fn test_sales_order_generation() {
        let mut gen = O2CGenerator::new(42);
        let customer = create_test_customer();
        let materials = create_test_materials();
        let material_refs: Vec<&Material> = materials.iter().collect();

        let so = gen.generate_sales_order(
            "1000",
            &customer,
            &material_refs,
            NaiveDate::from_ymd_opt(2024, 1, 15).unwrap(),
            2024,
            1,
            "JSMITH",
        );

        assert_eq!(so.customer_id, "C-000001");
        assert_eq!(so.items.len(), 2);
        assert!(so.total_net_amount > Decimal::ZERO);
    }

    #[test]
    fn test_credit_check_failure() {
        let config = O2CGeneratorConfig {
            credit_check_failure_rate: 1.0, // Force failure
            ..Default::default()
        };

        let mut gen = O2CGenerator::with_config(42, config);
        let customer = create_test_customer();
        let materials = create_test_materials();
        let material_refs: Vec<&Material> = materials.iter().collect();

        let chain = gen.generate_chain(
            "1000",
            &customer,
            &material_refs,
            NaiveDate::from_ymd_opt(2024, 1, 15).unwrap(),
            2024,
            1,
            "JSMITH",
        );

        assert!(!chain.credit_check_passed);
        assert!(chain.deliveries.is_empty());
        assert!(chain.customer_invoice.is_none());
    }

    #[test]
    fn test_document_references() {
        let mut gen = O2CGenerator::new(42);
        let customer = create_test_customer();
        let materials = create_test_materials();
        let material_refs: Vec<&Material> = materials.iter().collect();

        let chain = gen.generate_chain(
            "1000",
            &customer,
            &material_refs,
            NaiveDate::from_ymd_opt(2024, 1, 15).unwrap(),
            2024,
            1,
            "JSMITH",
        );

        // Delivery should reference SO
        if let Some(dlv) = chain.deliveries.first() {
            assert!(!dlv.header.document_references.is_empty());
        }

        // Invoice should reference SO and Delivery
        if let Some(invoice) = &chain.customer_invoice {
            assert!(invoice.header.document_references.len() >= 2);
        }
    }

    #[test]
    fn test_deterministic_generation() {
        let customer = create_test_customer();
        let materials = create_test_materials();
        let material_refs: Vec<&Material> = materials.iter().collect();

        let mut gen1 = O2CGenerator::new(42);
        let mut gen2 = O2CGenerator::new(42);

        let chain1 = gen1.generate_chain(
            "1000",
            &customer,
            &material_refs,
            NaiveDate::from_ymd_opt(2024, 1, 15).unwrap(),
            2024,
            1,
            "JSMITH",
        );
        let chain2 = gen2.generate_chain(
            "1000",
            &customer,
            &material_refs,
            NaiveDate::from_ymd_opt(2024, 1, 15).unwrap(),
            2024,
            1,
            "JSMITH",
        );

        assert_eq!(
            chain1.sales_order.header.document_id,
            chain2.sales_order.header.document_id
        );
        assert_eq!(
            chain1.sales_order.total_net_amount,
            chain2.sales_order.total_net_amount
        );
    }

    #[test]
    fn test_partial_shipment_config() {
        let config = O2CGeneratorConfig {
            partial_shipment_rate: 1.0, // Force partial shipment
            ..Default::default()
        };

        let mut gen = O2CGenerator::with_config(42, config);
        let customer = create_test_customer();
        let materials = create_test_materials();
        let material_refs: Vec<&Material> = materials.iter().collect();

        let chain = gen.generate_chain(
            "1000",
            &customer,
            &material_refs,
            NaiveDate::from_ymd_opt(2024, 1, 15).unwrap(),
            2024,
            1,
            "JSMITH",
        );

        // Should have multiple deliveries due to partial shipment
        assert!(chain.deliveries.len() >= 2);
    }

    #[test]
    fn test_gross_margin() {
        let mut gen = O2CGenerator::new(42);
        let customer = create_test_customer();
        let materials = create_test_materials();
        let material_refs: Vec<&Material> = materials.iter().collect();

        let chain = gen.generate_chain(
            "1000",
            &customer,
            &material_refs,
            NaiveDate::from_ymd_opt(2024, 1, 15).unwrap(),
            2024,
            1,
            "JSMITH",
        );

        if let Some(invoice) = &chain.customer_invoice {
            // Gross margin should be positive (revenue > COGS)
            let margin = invoice.gross_margin();
            assert!(margin > Decimal::ZERO, "Gross margin should be positive");
        }
    }
}
